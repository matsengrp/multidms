
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Biophysical model &#8212; multidms 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/nbsphinx-code-cells.css" />
    <script src="_static/jquery.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="multidms fitting pipeline" href="fit_delta_BA1_example.html" />
    <link rel="prev" title="Installation" href="installation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">IPython.core.display</span> <span class="k">as</span> <span class="nn">di</span> <span class="c1"># Example: di.display_html(&#39;&lt;h3&gt;%s:&lt;/h3&gt;&#39; % str, raw=True)</span>
<span class="n">di</span><span class="o">.</span><span class="n">display_html</span><span class="p">(</span><span class="s1">&#39;&lt;script&gt;jQuery(function() {if (jQuery(&quot;body.notebook_app&quot;).length == 0) { jQuery(&quot;.input_area&quot;).toggle(); jQuery(&quot;.prompt&quot;).toggle();}});&lt;/script&gt;&#39;</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<script>jQuery(function() {if (jQuery("body.notebook_app").length == 0) { jQuery(".input_area").toggle(); jQuery(".prompt").toggle();}});</script></div>
</div>
<section id="Biophysical-model">
<h1>Biophysical model<a class="headerlink" href="#Biophysical-model" title="Permalink to this heading"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">multidms</span></code> joint model applies primarily to a case where you have deep mutational scanning (DMS) datasets for two or more experimental conditions and are interested in identifying differences (i.e. <em>shifts</em>) in mutational effects between conditions. Here we describe the biophysical model of conditional shifts that motivates the approach in this package.</p>
<p>We suggest reading the <a class="reference external" href="https://www.pnas.org/doi/10.1073/pnas.1804015115">Otwinowski et al. 2018</a> paper to understand the approach for modeling global epistasis before reading the rest of the documentation.</p>
<section id="Model-overview">
<h2>Model overview<a class="headerlink" href="#Model-overview" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">multidms</span></code> extends the traditional global epistasis model by informing the parameters with multiple DMS experiments under differing experimental <em>conditions</em> (referred to as <span class="math notranslate nohighlight">\(h\)</span>). Distinct conditions may include non-homologous wildtype sequences between DMS experiments (i.e. SARS-CoV-2 Delta Vs. Omicron spike). However, this approach could also be used for experimental conditions which share homology of the wildtype, but are run with different selection steps. This model makes the
assumption that differing conditions should result in <em>mostly</em> the same effect of mutations – but some <em>shifts</em> in mutational effect due to biological mechanisms (i.e. epistasis). Ultimately, this model was designed to identify those shifts relative to user’s chosen <em>reference</em> condition with feature selection via a lasso “<span class="math notranslate nohighlight">\(L_{1}\)</span>” regularization of the shift parameters described in the additive latent phenotype section below.</p>
<p>At a high level, the model is a composition of three functions which describe the expected biophysical interactions underlying a given phenotype; (1) <span class="math notranslate nohighlight">\(\phi\)</span>, an additive model describing a variant’s <em>latent</em> phenotype under a given condition, (2) <span class="math notranslate nohighlight">\(g\)</span>, a global epistasis model shared by all conditions to disentangle the effects of multiple mutations on the same variant, and (3) <span class="math notranslate nohighlight">\(t\)</span>, a final output activation function accounting for the expected <em>lower bound</em> on any given
variant’s phenotype.</p>
<p>Concretely, the predicted phenotype for a given variant <span class="math notranslate nohighlight">\(v\)</span> under condition <span class="math notranslate nohighlight">\(h\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\hat{y}_{v,h} = t_{\gamma}(g_{\alpha}(\phi_{\beta, S, C_{r}}(v,h))\]</div>
<p>Where <span class="math notranslate nohighlight">\(\gamma\)</span>, <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(S\)</span>, and <span class="math notranslate nohighlight">\(C_{r}\)</span> are <em>free</em> parameters inferred from experimental observations during the fitting process. We describe the individual components and their associates parameters in more detail below.</p>
<p><strong>Note</strong> The motivation behind defining an abstract model in terms of its components provides (1) modularity for method testing and development, and (2) multiple options for model components. While there is only a single option for the latent prediction, <span class="math notranslate nohighlight">\(\phi\)</span>, we offer a few options <em>post-latent</em> modeling, <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(t\)</span>, that encompass the needs of differing research goals and experimental techniques. Generally speaking, the package defaults for these components should be
sufficient for most purposes, and in this case feel free to ignore the <code class="docutils literal notranslate"><span class="pre">multidms.biophysical</span></code> module all-together as this functionality is hidden unless explicitly specified during the instantiation of a <code class="docutils literal notranslate"><span class="pre">MultiDmsModel</span></code> object.</p>
</section>
<section id="Normalizing-observed-functional-scores-using-\gamma_{h}">
<h2>Normalizing observed functional scores using <span class="math notranslate nohighlight">\(\gamma_{h}\)</span><a class="headerlink" href="#Normalizing-observed-functional-scores-using-\gamma_{h}" title="Permalink to this heading"></a></h2>
<p>The first consideration is whether observed functional scores are directly comparable between conditions. In context of the model, <em>Predicted</em> functional scores are all directly comparable since all are generated from the same latent space via the same global-epistasis function. However, observed scores may not be comparable in the same way. For instance, a common way to compute functional scores is with log enrichment ratios, normalized so that the wildtype sequence has a value of zero. If the
conditions being compared are DMS experiments conducted in the background of different homologs, then each homolog will necessarily have a functional score of zero within its experiment, even if those same homologs would have different functional scores when measured in the same experiment. Thus, log enrichment ratios are not always directly comparable between experiments. Ideally, one or more of the same sequences would be included in the experimental design of DMS libraries to be compared and
normalized to the same sequence. However, if there are no such sequences, then it may be possible to computationally estimate how to renormalize scores.</p>
<p>To this end, the model includes an additional parameter <span class="math notranslate nohighlight">\(\gamma_h\)</span> for each non-reference condition that allows functional scores, <span class="math notranslate nohighlight">\(y'_{v,h}\)</span> from that condition to be renormalized as follows:</p>
<div class="math notranslate nohighlight">
\[y'_{v,h} = y_{v,h} + \gamma_h\]</div>
<p>where <span class="math notranslate nohighlight">\(\gamma_h\)</span> for the reference condition is locked at zero. There is a theoretical basis for adding <span class="math notranslate nohighlight">\(\gamma_h\)</span> to <span class="math notranslate nohighlight">\(y_{v,h}\)</span> if functional scores are log enrichment ratios. As mentioned above, log enrichment ratios are normalized so that the wildtype sequence from a given experiment has a value of zero, according to the formula:</p>
<div class="math notranslate nohighlight">
\[y_{v,h} = \log(E_{v,h}) - \log(E_{\text{wt},h})\]</div>
<p>Thus, adding <span class="math notranslate nohighlight">\(\gamma_d\)</span> to <span class="math notranslate nohighlight">\(y_{v,d}\)</span> is akin to renormalizing the log enrichment ratios so that a different sequence has a functional score of zero. In theory, for each non-reference condition, there is a <span class="math notranslate nohighlight">\(\gamma_d\)</span> that renormalizes functional scores to be relative to the wildtype sequence of the reference condition. If these values are not experimentally measured, the model allows <span class="math notranslate nohighlight">\(\gamma_d\)</span> parameters to be fit during optimization, which assumes that the correct
<span class="math notranslate nohighlight">\(\gamma_d\)</span> values will give the best model fit.</p>
</section>
<section id="Additive-latent-phenotype,-\phi">
<h2>Additive latent phenotype, <span class="math notranslate nohighlight">\(\phi\)</span><a class="headerlink" href="#Additive-latent-phenotype,-\phi" title="Permalink to this heading"></a></h2>
<p>For each mutation <span class="math notranslate nohighlight">\(m\)</span>, the model defines a single mutation effect parameter, <span class="math notranslate nohighlight">\(\beta_{m}\)</span> shared by all conditions. Additionally, the model defines the set of shift parameters, <span class="math notranslate nohighlight">\(s_{m,h}\)</span>, that quantifies the shift a given mutation’s effect relative to some reference condition. Each mutation, for each non-reference condition, is associated with an independent shift parameter. For example, if there exists three total experimental conditions, <span class="math notranslate nohighlight">\(h \in \{h_{1}, h_{2}\)</span>,
<span class="math notranslate nohighlight">\(h_{3}\}\)</span>, and we define <span class="math notranslate nohighlight">\(h_{1}\)</span> to be the <em>reference</em> condition, the model defines two sets of non-reference <em>shift</em> parameters <span class="math notranslate nohighlight">\(s_{m, h_{2}}\)</span>, <span class="math notranslate nohighlight">\(s_{m, h_{3}}\)</span> that may be fit to non-zero values. Note that while a <span class="math notranslate nohighlight">\(s_{m, h_{1}}\)</span> does exist for computational and mathemathical coherency, it is locked to <span class="math notranslate nohighlight">\(0\)</span> during the fitting procedure and is functionally ignored.</p>
<p>Concretely, the latent phenotype of any variant, <span class="math notranslate nohighlight">\(v\)</span>, from the experimental condition, <span class="math notranslate nohighlight">\(h\)</span>, is computed like so:</p>
<div class="math notranslate nohighlight">
\[\phi(v,h) = c_{r} + \sum_{m \in v} (\beta_{m} + S_{m,h})\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(c_{r}\)</span> is the wildtype latent phenotype for the reference condition.</p></li>
<li><p><span class="math notranslate nohighlight">\(\beta_{m}\)</span> is the latent phenotypic effect of mutation <span class="math notranslate nohighlight">\(m\)</span> (See the note below),</p></li>
<li><p><span class="math notranslate nohighlight">\(s_{m,h}\)</span> is the shift of the effect of mutation <span class="math notranslate nohighlight">\(m\)</span> in condition <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(v\)</span> is the set of all mutations relative to the reference wild type sequence including all potential non-identical wildtype mutations that separate condition <span class="math notranslate nohighlight">\(h\)</span> from the reference condition.</p></li>
</ul>
<p>As stated in the overview abive, we expect the mutation effect among conditions to largely be the same. By applying a <em>lasso</em> <span class="math notranslate nohighlight">\(L_{1}\)</span> regularization term to shift parameters we encourage most <span class="math notranslate nohighlight">\(s_{m,h}\)</span> to be zero, while identifying non-zero shifts with confidence. We find that the model is robust for most reasable choices of regularization strength. See the fitting procedure below for more on this.</p>
<p><strong>Note</strong> The <span class="math notranslate nohighlight">\(\beta_m\)</span> variable is defined such that mutations are always relative to the reference condition. For example, if the wild type amino acid at site 30 is an A in the reference condition, and a G in a non-reference condition, then a Y30G mutation in the non-reference condition is recorded as an A30G mutation relative to the reference. This way, each condition informs the exact same parameters, even at sites that differ in wild type amino acid. These are encoded in a
<code class="docutils literal notranslate"><span class="pre">BinaryMap</span></code> object, where all sites that are non-identical to the reference are 1’s.</p>
</section>
<section id="global-epistasis,-g">
<h2>global epistasis, <span class="math notranslate nohighlight">\(g\)</span><a class="headerlink" href="#global-epistasis,-g" title="Permalink to this heading"></a></h2>
<p>Latent phenotypes as described above give rise to functional scores according to a global-epistasis function. If this function is non-linear, then the model allows mutations to non-additively effect functional scores, helping to account for global epistasis. Here, we’ll go into more detail about the options available in <code class="docutils literal notranslate"><span class="pre">multidms</span></code></p>
<section id="Sigmoidal:">
<h3>Sigmoidal:<a class="headerlink" href="#Sigmoidal:" title="Permalink to this heading"></a></h3>
<p>By default, the global-epistasis function here assumes a sigmoidal relationship between a protein’s latent property and it’s functional score measured in the experiment (e.g., log enrichment score). Using free parameters, the sigmoid can flexibly conform to an optimal shape informed by the data. Note that this function is independent from the experimental condition from which a variant is observed.</p>
<p>The sigmoidal function that relates a given <em>latent phenotype</em>, <span class="math notranslate nohighlight">\(z\)</span>, to its functional score is given by:</p>
<div class="math notranslate nohighlight">
\[g(z) =  \frac{\alpha_{scale}}{1 + e^{-z}} + \alpha_{bias}\]</div>
<p>Where <span class="math notranslate nohighlight">\(\alpha_{scale}\)</span> and <span class="math notranslate nohighlight">\(\alpha_{bias}\)</span> are free parameters defining the range and lower bound of the sigmoid, respectively.</p>
<p>Below is an interactive plot showing the effect of the sigmoidal global epistasis as a function of an adjustable <span class="math notranslate nohighlight">\(\alpha_{scale}\)</span>, and <span class="math notranslate nohighlight">\(\alpha_{bias}\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">altair</span> <span class="k">as</span> <span class="nn">alt</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;latent&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)})</span>

<span class="n">slider_s</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">binding_range</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">var_s</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">slider_s</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;alpha_scale&quot;</span><span class="p">)</span>

<span class="n">slider_b</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">binding_range</span><span class="p">(</span><span class="nb">min</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">var_b</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">slider_b</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;alpha_bias&quot;</span><span class="p">)</span>

<span class="p">(</span>
    <span class="n">alt</span><span class="o">.</span><span class="n">Chart</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="o">.</span><span class="n">transform_calculate</span><span class="p">(</span>
        <span class="n">phenotype</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">alt</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">alt</span><span class="o">.</span><span class="n">datum</span><span class="p">[</span><span class="s1">&#39;latent&#39;</span><span class="p">])))</span>
        <span class="o">*</span> <span class="n">var_s</span>
        <span class="o">+</span> <span class="n">var_b</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">encode</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="s2">&quot;latent&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;latent phenotype&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])),</span>
        <span class="n">y</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="s2">&quot;phenotype:Q&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;predicted phenotype&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">mark_line</span><span class="p">()</span>
    <span class="o">.</span><span class="n">add_params</span><span class="p">(</span><span class="n">var_s</span><span class="p">,</span> <span class="n">var_b</span><span class="p">)</span>
<span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<div id="altair-viz-7ca76b8e757449608543347f8946535f"></div>
<script type="text/javascript">
  var VEGA_DEBUG = (typeof VEGA_DEBUG == "undefined") ? {} : VEGA_DEBUG;
  (function(spec, embedOpt){
    let outputDiv = document.currentScript.previousElementSibling;
    if (outputDiv.id !== "altair-viz-7ca76b8e757449608543347f8946535f") {
      outputDiv = document.getElementById("altair-viz-7ca76b8e757449608543347f8946535f");
    }
    const paths = {
      "vega": "https://cdn.jsdelivr.net/npm/vega@5?noext",
      "vega-lib": "https://cdn.jsdelivr.net/npm/vega-lib?noext",
      "vega-lite": "https://cdn.jsdelivr.net/npm/vega-lite@5.6.1?noext",
      "vega-embed": "https://cdn.jsdelivr.net/npm/vega-embed@6?noext",
    };

    function maybeLoadScript(lib, version) {
      var key = `${lib.replace("-", "")}_version`;
      return (VEGA_DEBUG[key] == version) ?
        Promise.resolve(paths[lib]) :
        new Promise(function(resolve, reject) {
          var s = document.createElement('script');
          document.getElementsByTagName("head")[0].appendChild(s);
          s.async = true;
          s.onload = () => {
            VEGA_DEBUG[key] = version;
            return resolve(paths[lib]);
          };
          s.onerror = () => reject(`Error loading script: ${paths[lib]}`);
          s.src = paths[lib];
        });
    }

    function showError(err) {
      outputDiv.innerHTML = `<div class="error" style="color:red;">${err}</div>`;
      throw err;
    }

    function displayChart(vegaEmbed) {
      vegaEmbed(outputDiv, spec, embedOpt)
        .catch(err => showError(`Javascript Error: ${err.message}<br>This usually means there's a typo in your chart specification. See the javascript console for the full traceback.`));
    }

    if(typeof define === "function" && define.amd) {
      requirejs.config({paths});
      require(["vega-embed"], displayChart, err => showError(`Error loading script: ${err.message}`));
    } else {
      maybeLoadScript("vega", "5")
        .then(() => maybeLoadScript("vega-lite", "5.6.1"))
        .then(() => maybeLoadScript("vega-embed", "6"))
        .catch(showError)
        .then(() => displayChart(vegaEmbed));
    }
  })({"config": {"view": {"continuousWidth": 300, "continuousHeight": 300}}, "data": {"name": "data-5df0d8288b8899ccb5d4c64cc03b51be"}, "mark": {"type": "line"}, "encoding": {"x": {"field": "latent", "scale": {"domain": [-10, 10]}, "title": "latent phenotype", "type": "quantitative"}, "y": {"field": "phenotype", "scale": {"domain": [-10, 10]}, "title": "predicted phenotype", "type": "quantitative"}}, "params": [{"name": "alpha_scale", "bind": {"input": "range", "max": 10, "min": 0.1}, "value": 5}, {"name": "alpha_bias", "bind": {"input": "range", "max": 5, "min": -10}, "value": 0}], "transform": [{"calculate": "(((1 / (1 + exp((-1 * datum['latent'])))) * alpha_scale) + alpha_bias)", "as": "phenotype"}], "$schema": "https://vega.github.io/schema/vega-lite/v5.6.1.json", "datasets": {"data-5df0d8288b8899ccb5d4c64cc03b51be": [{"latent": -10.0}, {"latent": -9.797979797979798}, {"latent": -9.595959595959595}, {"latent": -9.393939393939394}, {"latent": -9.191919191919192}, {"latent": -8.98989898989899}, {"latent": -8.787878787878787}, {"latent": -8.585858585858587}, {"latent": -8.383838383838384}, {"latent": -8.181818181818182}, {"latent": -7.979797979797979}, {"latent": -7.777777777777778}, {"latent": -7.575757575757576}, {"latent": -7.373737373737374}, {"latent": -7.171717171717171}, {"latent": -6.96969696969697}, {"latent": -6.767676767676768}, {"latent": -6.565656565656566}, {"latent": -6.363636363636363}, {"latent": -6.161616161616162}, {"latent": -5.959595959595959}, {"latent": -5.757575757575758}, {"latent": -5.555555555555555}, {"latent": -5.353535353535354}, {"latent": -5.151515151515151}, {"latent": -4.94949494949495}, {"latent": -4.747474747474747}, {"latent": -4.545454545454546}, {"latent": -4.343434343434343}, {"latent": -4.141414141414142}, {"latent": -3.9393939393939394}, {"latent": -3.737373737373738}, {"latent": -3.5353535353535355}, {"latent": -3.333333333333333}, {"latent": -3.1313131313131315}, {"latent": -2.929292929292929}, {"latent": -2.7272727272727275}, {"latent": -2.525252525252525}, {"latent": -2.3232323232323235}, {"latent": -2.121212121212121}, {"latent": -1.9191919191919187}, {"latent": -1.717171717171718}, {"latent": -1.5151515151515156}, {"latent": -1.3131313131313131}, {"latent": -1.1111111111111107}, {"latent": -0.9090909090909101}, {"latent": -0.7070707070707076}, {"latent": -0.5050505050505052}, {"latent": -0.30303030303030276}, {"latent": -0.10101010101010033}, {"latent": 0.10101010101010033}, {"latent": 0.30303030303030276}, {"latent": 0.5050505050505052}, {"latent": 0.7070707070707076}, {"latent": 0.9090909090909083}, {"latent": 1.1111111111111107}, {"latent": 1.3131313131313131}, {"latent": 1.5151515151515156}, {"latent": 1.7171717171717162}, {"latent": 1.9191919191919187}, {"latent": 2.121212121212121}, {"latent": 2.3232323232323235}, {"latent": 2.525252525252524}, {"latent": 2.7272727272727266}, {"latent": 2.929292929292929}, {"latent": 3.1313131313131315}, {"latent": 3.333333333333334}, {"latent": 3.5353535353535346}, {"latent": 3.737373737373737}, {"latent": 3.9393939393939394}, {"latent": 4.141414141414142}, {"latent": 4.3434343434343425}, {"latent": 4.545454545454545}, {"latent": 4.747474747474747}, {"latent": 4.94949494949495}, {"latent": 5.1515151515151505}, {"latent": 5.353535353535353}, {"latent": 5.555555555555555}, {"latent": 5.757575757575758}, {"latent": 5.9595959595959584}, {"latent": 6.161616161616163}, {"latent": 6.363636363636363}, {"latent": 6.565656565656564}, {"latent": 6.767676767676768}, {"latent": 6.969696969696969}, {"latent": 7.171717171717173}, {"latent": 7.373737373737374}, {"latent": 7.575757575757574}, {"latent": 7.777777777777779}, {"latent": 7.979797979797979}, {"latent": 8.18181818181818}, {"latent": 8.383838383838384}, {"latent": 8.585858585858585}, {"latent": 8.787878787878789}, {"latent": 8.98989898989899}, {"latent": 9.19191919191919}, {"latent": 9.393939393939394}, {"latent": 9.595959595959595}, {"latent": 9.7979797979798}, {"latent": 10.0}]}}, {"mode": "vega-lite"});
</script></div>
</div>
</section>
<section id="Single-layer-neural-network-epistasis:">
<h3>Single-layer neural network epistasis:<a class="headerlink" href="#Single-layer-neural-network-epistasis:" title="Permalink to this heading"></a></h3>
<p>If you prefer a less constrained shape for global epistasis, we also offer the ability to learn the shape of global epistasis using a single-layer neural network, sometimes referred to as a <a class="reference external" href="https://en.wikipedia.org/wiki/Multilayer_perceptron">multi-layer perceptron</a>. For this option, the user defines a number of units in the singular hidden layer of the model. For each hidden unit, we introduce three parameters (two weights and a bias) to be inferred. All weights are clipped at zero to
maintain assumptions of monotonicity in the resulting epistasis function shape. The network applies a sigmoid activation to each internal unit before a final transformation and addition of a constant gives us our predicted functional score.</p>
<p>Given a latent phenotype, <span class="math notranslate nohighlight">\(z\)</span>, the neural network function can then be defined:</p>
<div class="math notranslate nohighlight">
\[g(z) = b^{o}+ \sum_{i}^{n}(\frac{w^{o}_{i}}{1 + e^{w^{l}_{i}*z + b^{l}_{i}}})\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n\)</span> is the number of units in the hidden layer.</p></li>
<li><p><span class="math notranslate nohighlight">\(w^{l}_{i}\)</span> and <span class="math notranslate nohighlight">\(w^{o}_{i}\)</span> are free parameters representing latent and output tranformations, respectively, associated with unit <span class="math notranslate nohighlight">\(i\)</span> in the hidden layer of the network.</p></li>
<li><p><span class="math notranslate nohighlight">\(b^{l}_{i}\)</span> is a free parameter, as an added bias term to unit <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(b^{o}\)</span> is a constant, singular free parameter.</p></li>
</ul>
<p><strong>Note</strong> In the <code class="docutils literal notranslate"><span class="pre">multidms</span></code> API, This behavior is accomplished by setting the “output_activation” parameter in the constructor for <code class="docutils literal notranslate"><span class="pre">MultiDmsModel</span></code> to be a pointer to the function <code class="docutils literal notranslate"><span class="pre">multidms.biophysical.single_layer_nn</span></code></p>
</section>
<section id="Identity-(no-epistasis):">
<h3>Identity (no epistasis):<a class="headerlink" href="#Identity-(no-epistasis):" title="Permalink to this heading"></a></h3>
<p>In some scenerios, deep mutational scanning data only contains single-mutation variants to be observed. It then becomes hopeless to learn anything useful about epiststatic effects. In this scenerio, we provide the option to functionally disable any global epistsis modeling by setting <span class="math notranslate nohighlight">\(g(z) = z\)</span>.</p>
<p><strong>Note</strong> In the <code class="docutils literal notranslate"><span class="pre">multidms</span></code> API, This is accomplished by setting the “output_activation” parameter in the constructor for <code class="docutils literal notranslate"><span class="pre">MultiDmsModel</span></code> to be a pointer to the function definition <code class="docutils literal notranslate"><span class="pre">multidms.biophysical.identity_activation</span></code></p>
</section>
</section>
<section id="Output-activation,-t">
<h2>Output activation, <span class="math notranslate nohighlight">\(t\)</span><a class="headerlink" href="#Output-activation,-t" title="Permalink to this heading"></a></h2>
<p>The commonly reported fold-change metric for functional scores described above falls victim to reported outliers. This is particularly problematic when the starting frequency of a barcoded variant is low. Common solutions to this sensitivity problem include the use of highly multiplexed assays with variant-level barcode replicates, as well simply filtering out low frequency variants. Unfortunatly, even modest filtering thresholds for starting frequency and number of barcode replicates may cut
out informative signal for the model. Thus, it’s also common for researchers to simply <em>truncate</em> (i.e. <em>clip</em>) the functional at some lower bound <span class="math notranslate nohighlight">\(l\)</span>, where observations below are assumed largely to be outlier.</p>
<p>This type of truncation in the data leads to unwanted behavior in our global epistasis model. Put simply, <span class="math notranslate nohighlight">\(g\)</span> <em>learns</em> this lower bound, and thus is encouraged to limit it’s shape to conform to this lower bound during the fitting process. This behavior is particularly problematic when normalizing the observed functional scores with <span class="math notranslate nohighlight">\(\gamma_{h}\)</span>, described above. To provide intuition, consider a scenario where observed functional scores are truncated at a lower bound of -3 across all
conditions. If <span class="math notranslate nohighlight">\(\gamma_d\)</span> is fit to -1.0 for one of the non-reference conditions, then the new floor of functional scores will be -4 for that condition, while the floor for the reference condition would still be -3. In this case, the global epistasis function could find itself in a pickle: if it allows predictions to go below -3, it could help model the floor of points in the non-reference condition, but hurt with modeling the floor of points in the reference condition.</p>
<section id="Softplus">
<h3>Softplus<a class="headerlink" href="#Softplus" title="Permalink to this heading"></a></h3>
<p>By default, we avoid this unwanted behavior by applying a final activation on the output of the global epistasis model. In essence, this is a modified <em>softplus</em> activation, (<span class="math notranslate nohighlight">\(\text{softplus}(x)=\log(1 + e^{x})\)</span>) with a <em>lower bound</em> at <span class="math notranslate nohighlight">\(l + \gamma_{h}\)</span>, as well as a <em>ramping</em> coefficient, <span class="math notranslate nohighlight">\(\lambda_{\text{sp}}\)</span>.</p>
<p>Concretely, if we let <span class="math notranslate nohighlight">\(z' = g(\phi(v,h))\)</span>, then the predicted functional score of our model is given by:</p>
<div class="math notranslate nohighlight">
\[t(z') = \lambda_{sp}\log(1 + e^{\frac{z' - l}{\lambda_{sp}}}) + l\]</div>
<p>Functionally speaking, this truncates scores below a lower bound, while leaving scores above (mostly) unaltered. There is a small range of input values where the function smoothly transitions between a flat regime (where data is truncated) and a linear regime (where data is not truncated).</p>
<p><strong>Note</strong> By default, we recommend leaving the <span class="math notranslate nohighlight">\(\lambda_{sp}\)</span> parameter at it’s default value of <span class="math notranslate nohighlight">\(0.1\)</span>. this ensures a sharp transition between regimes similar to a <a class="reference external" href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)">ReLU</a> function, but retain the differentible property for gradient based optimization.</p>
<p>Below is an interactive plot showing the effect of the modified softplus activation as a function of an adjustable <span class="math notranslate nohighlight">\(\lambda_{sp}\)</span> scaling parameter, and lower bound, <span class="math notranslate nohighlight">\(l\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">altair</span> <span class="k">as</span> <span class="nn">alt</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;latent&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)})</span>

<span class="n">slider_lsp</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">binding_range</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">var_lambda_sp</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">slider_lsp</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;lambda_sp&quot;</span><span class="p">)</span>

<span class="n">slider_lb</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">binding_range</span><span class="p">(</span><span class="nb">min</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">var_lower_bound</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">slider_lb</span><span class="p">,</span> <span class="n">value</span><span class="o">=-</span><span class="mf">3.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;lower_bound&quot;</span><span class="p">)</span>

<span class="p">(</span>
    <span class="n">alt</span><span class="o">.</span><span class="n">Chart</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="o">.</span><span class="n">transform_calculate</span><span class="p">(</span>
        <span class="n">phenotype</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">alt</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">alt</span><span class="o">.</span><span class="n">datum</span><span class="p">[</span><span class="s1">&#39;latent&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">var_lower_bound</span><span class="p">)</span><span class="o">/</span><span class="n">var_lambda_sp</span><span class="p">))</span>
        <span class="o">*</span> <span class="n">var_lambda_sp</span>
        <span class="o">+</span> <span class="n">var_lower_bound</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">encode</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="s2">&quot;latent&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;global epistasis prediction (z&#39;)&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">])),</span>
        <span class="n">y</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="s2">&quot;phenotype:Q&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;predicted phenotype&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">mark_line</span><span class="p">()</span>
    <span class="o">.</span><span class="n">add_params</span><span class="p">(</span><span class="n">var_lambda_sp</span><span class="p">,</span> <span class="n">var_lower_bound</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<div id="altair-viz-a4f405dae86b44a78b4d3c3313a4af83"></div>
<script type="text/javascript">
  var VEGA_DEBUG = (typeof VEGA_DEBUG == "undefined") ? {} : VEGA_DEBUG;
  (function(spec, embedOpt){
    let outputDiv = document.currentScript.previousElementSibling;
    if (outputDiv.id !== "altair-viz-a4f405dae86b44a78b4d3c3313a4af83") {
      outputDiv = document.getElementById("altair-viz-a4f405dae86b44a78b4d3c3313a4af83");
    }
    const paths = {
      "vega": "https://cdn.jsdelivr.net/npm/vega@5?noext",
      "vega-lib": "https://cdn.jsdelivr.net/npm/vega-lib?noext",
      "vega-lite": "https://cdn.jsdelivr.net/npm/vega-lite@5.6.1?noext",
      "vega-embed": "https://cdn.jsdelivr.net/npm/vega-embed@6?noext",
    };

    function maybeLoadScript(lib, version) {
      var key = `${lib.replace("-", "")}_version`;
      return (VEGA_DEBUG[key] == version) ?
        Promise.resolve(paths[lib]) :
        new Promise(function(resolve, reject) {
          var s = document.createElement('script');
          document.getElementsByTagName("head")[0].appendChild(s);
          s.async = true;
          s.onload = () => {
            VEGA_DEBUG[key] = version;
            return resolve(paths[lib]);
          };
          s.onerror = () => reject(`Error loading script: ${paths[lib]}`);
          s.src = paths[lib];
        });
    }

    function showError(err) {
      outputDiv.innerHTML = `<div class="error" style="color:red;">${err}</div>`;
      throw err;
    }

    function displayChart(vegaEmbed) {
      vegaEmbed(outputDiv, spec, embedOpt)
        .catch(err => showError(`Javascript Error: ${err.message}<br>This usually means there's a typo in your chart specification. See the javascript console for the full traceback.`));
    }

    if(typeof define === "function" && define.amd) {
      requirejs.config({paths});
      require(["vega-embed"], displayChart, err => showError(`Error loading script: ${err.message}`));
    } else {
      maybeLoadScript("vega", "5")
        .then(() => maybeLoadScript("vega-lite", "5.6.1"))
        .then(() => maybeLoadScript("vega-embed", "6"))
        .catch(showError)
        .then(() => displayChart(vegaEmbed));
    }
  })({"config": {"view": {"continuousWidth": 300, "continuousHeight": 300}}, "data": {"name": "data-cabdca2257cf20e376d04c62a66e94ee"}, "mark": {"type": "line"}, "encoding": {"x": {"field": "latent", "scale": {"domain": [-10, 5]}, "title": "global epistasis prediction (z')", "type": "quantitative"}, "y": {"field": "phenotype", "scale": {"domain": [-10, 5]}, "title": "predicted phenotype", "type": "quantitative"}}, "params": [{"name": "lambda_sp", "bind": {"input": "range", "max": 2, "min": 0.1}, "value": 1}, {"name": "lower_bound", "bind": {"input": "range", "max": 0, "min": -10}, "value": -3.5}], "transform": [{"calculate": "((log((1 + exp(((datum['latent'] - lower_bound) / lambda_sp)))) * lambda_sp) + lower_bound)", "as": "phenotype"}], "$schema": "https://vega.github.io/schema/vega-lite/v5.6.1.json", "datasets": {"data-cabdca2257cf20e376d04c62a66e94ee": [{"latent": -10.0}, {"latent": -9.848484848484848}, {"latent": -9.696969696969697}, {"latent": -9.545454545454545}, {"latent": -9.393939393939394}, {"latent": -9.242424242424242}, {"latent": -9.09090909090909}, {"latent": -8.93939393939394}, {"latent": -8.787878787878787}, {"latent": -8.636363636363637}, {"latent": -8.484848484848484}, {"latent": -8.333333333333334}, {"latent": -8.181818181818182}, {"latent": -8.030303030303031}, {"latent": -7.878787878787879}, {"latent": -7.727272727272727}, {"latent": -7.575757575757576}, {"latent": -7.424242424242424}, {"latent": -7.2727272727272725}, {"latent": -7.121212121212121}, {"latent": -6.96969696969697}, {"latent": -6.818181818181818}, {"latent": -6.666666666666666}, {"latent": -6.515151515151516}, {"latent": -6.363636363636363}, {"latent": -6.212121212121212}, {"latent": -6.0606060606060606}, {"latent": -5.909090909090909}, {"latent": -5.757575757575758}, {"latent": -5.6060606060606055}, {"latent": -5.454545454545454}, {"latent": -5.303030303030303}, {"latent": -5.151515151515151}, {"latent": -5.0}, {"latent": -4.848484848484849}, {"latent": -4.696969696969697}, {"latent": -4.545454545454545}, {"latent": -4.393939393939394}, {"latent": -4.242424242424242}, {"latent": -4.090909090909091}, {"latent": -3.9393939393939394}, {"latent": -3.787878787878788}, {"latent": -3.636363636363636}, {"latent": -3.4848484848484844}, {"latent": -3.333333333333333}, {"latent": -3.1818181818181817}, {"latent": -3.0303030303030303}, {"latent": -2.878787878787879}, {"latent": -2.7272727272727266}, {"latent": -2.5757575757575752}, {"latent": -2.424242424242424}, {"latent": -2.2727272727272725}, {"latent": -2.121212121212121}, {"latent": -1.9696969696969688}, {"latent": -1.8181818181818183}, {"latent": -1.666666666666666}, {"latent": -1.5151515151515156}, {"latent": -1.3636363636363633}, {"latent": -1.212121212121211}, {"latent": -1.0606060606060606}, {"latent": -0.9090909090909083}, {"latent": -0.7575757575757578}, {"latent": -0.6060606060606055}, {"latent": -0.45454545454545503}, {"latent": -0.30303030303030276}, {"latent": -0.1515151515151505}, {"latent": 0.0}, {"latent": 0.15151515151515227}, {"latent": 0.30303030303030276}, {"latent": 0.45454545454545503}, {"latent": 0.6060606060606055}, {"latent": 0.7575757575757578}, {"latent": 0.9090909090909101}, {"latent": 1.0606060606060606}, {"latent": 1.2121212121212128}, {"latent": 1.3636363636363633}, {"latent": 1.5151515151515156}, {"latent": 1.6666666666666679}, {"latent": 1.8181818181818183}, {"latent": 1.9696969696969706}, {"latent": 2.121212121212121}, {"latent": 2.2727272727272734}, {"latent": 2.424242424242424}, {"latent": 2.575757575757576}, {"latent": 2.7272727272727284}, {"latent": 2.878787878787879}, {"latent": 3.030303030303031}, {"latent": 3.1818181818181817}, {"latent": 3.333333333333334}, {"latent": 3.4848484848484844}, {"latent": 3.6363636363636367}, {"latent": 3.787878787878789}, {"latent": 3.9393939393939394}, {"latent": 4.090909090909092}, {"latent": 4.242424242424242}, {"latent": 4.3939393939393945}, {"latent": 4.545454545454547}, {"latent": 4.696969696969697}, {"latent": 4.8484848484848495}, {"latent": 5.0}]}}, {"mode": "vega-lite"});
</script></div>
</div>
</section>
<section id="Identity-(no-activation):">
<h3>Identity (no activation):<a class="headerlink" href="#Identity-(no-activation):" title="Permalink to this heading"></a></h3>
<p>We offer the option to functionally <em>disable</em> this feature in the case where there’s no expected floor on the range of fitting data.</p>
<p><strong>Note</strong> In the <code class="docutils literal notranslate"><span class="pre">multidms</span></code> API, This is accomplished by setting the “output_activation” parameter in the constructor for <code class="docutils literal notranslate"><span class="pre">MultiDmsModel</span></code> to be a pointer to the function definition <code class="docutils literal notranslate"><span class="pre">multidms.biophysical.identity_activation</span></code></p>
</section>
</section>
<section id="Fitting-procedure">
<h2>Fitting procedure<a class="headerlink" href="#Fitting-procedure" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">multidms</span></code> is implimented in <em>python</em> using the <a class="reference external" href="https://github.com/google/jax">JAX</a> library. This allows for the direct differentiation of the composed model. The <a class="reference external" href="https://jaxopt.github.io/stable/index.html">jaxopt</a> package is used for effecient optimization of all parameters with <a class="reference external" href="https://en.wikipedia.org/wiki/Proximal_gradient_method">proximal gradient descent</a>. Given DMS training data, The objective is to minimize the difference between <em>normalized observed</em> and <em>predected</em>
functional scores (<span class="math notranslate nohighlight">\(y'_{v, h} - \hat{y}\)</span>). We apply a lasso <span class="math notranslate nohighlight">\(L^{1}\)</span> penalty to all <span class="math notranslate nohighlight">\(s_{v,h}\)</span> parameters for feature selection of high confidence values, and encouraging the rest to be <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>The total loss on a dataset is computed as the sum of the individual losses for each condition in the dataset.</p>
<div class="math notranslate nohighlight">
\[L_{\text{total}} = \sum_{h} [L_{\text{fit},h} + L_{\text{reg},h}]\]</div>
<p>conditional loss is then given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
L_{\text{fit},h} &amp;= \frac{\sum_{v} L_{\text{Huber}}(y'_{v,h}, t(v,h))}{n_h} \\
L_{\text{reg},h} &amp;= \lambda \sum_{m} |s_{m,h}|
\end{align}\end{split}\]</div>
<p>Where; <span class="math notranslate nohighlight">\(L_{\text{Huber}}\)</span> is a Huber loss function and <span class="math notranslate nohighlight">\(n_{h}\)</span> is the number of variants in the condition.</p>
<p>Dividing the numerator <span class="math notranslate nohighlight">\(L_{\text{fit},h}\)</span> by <span class="math notranslate nohighlight">\(n_h\)</span> makes it so that <span class="math notranslate nohighlight">\(L_{\text{fit},h}\)</span> returns the average loss across all variants. Ultimitely, this ensures that each condition contributes equally to <span class="math notranslate nohighlight">\(L_\text{total}\)</span>, regardless of the number of variants in that condition.</p>
<p><strong>Note</strong> We find the qualitative results of model fits and their respective shift parameters are quite robust for a reasonable choice of <span class="math notranslate nohighlight">\(\lambda\)</span> applied to the lasso. In other words, this parameter can be set to reflect the user’s own preference for <a class="reference external" href="https://en.wikipedia.org/wiki/Lasso_(statistics)">accuracy-simplicity</a> tradeoff.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/2020-logo-1000px-transparent.png" alt="Logo"/>
    
    <h1 class="logo logo-name">multidms</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=matsengrp&repo=multidms&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">multidms documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Biophysical model</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit_delta_BA1_example.html"><code class="docutils literal notranslate"><span class="pre">multidms</span></code> fitting pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="autodoc.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgments.html">Acknowledgments</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="installation.html" title="previous chapter">Installation</a></li>
      <li>Next: <a href="fit_delta_BA1_example.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">multidms</span></code> fitting pipeline</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Jared Galloway, Hugh Haddox.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/biophysical_model.nblink.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/matsengrp/multidms" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>